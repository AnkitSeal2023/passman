// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: db_queries.sql

package db

import (
	"context"
	"database/sql"
)

const createCredential = `-- name: CreateCredential :exec
INSERT INTO credentials (vault_item_id, encryptedCredName, encryptedCredPassword) VALUES ($1, $2, $3)
`

type CreateCredentialParams struct {
	VaultItemID           int32
	Encryptedcredname     string
	Encryptedcredpassword string
}

func (q *Queries) CreateCredential(ctx context.Context, arg CreateCredentialParams) error {
	_, err := q.db.ExecContext(ctx, createCredential, arg.VaultItemID, arg.Encryptedcredname, arg.Encryptedcredpassword)
	return err
}

const createUser = `-- name: CreateUser :exec
INSERT INTO users (username, master_password_hash, session_token) VALUES ($1, $2, $3)
`

type CreateUserParams struct {
	Username           string
	MasterPasswordHash string
	SessionToken       sql.NullString
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.ExecContext(ctx, createUser, arg.Username, arg.MasterPasswordHash, arg.SessionToken)
	return err
}

const createVaultItem = `-- name: CreateVaultItem :exec
INSERT INTO vault_items (vault_id, vault_item_name_encrypted) VALUES ($1, $2)
`

type CreateVaultItemParams struct {
	VaultID                int32
	VaultItemNameEncrypted string
}

func (q *Queries) CreateVaultItem(ctx context.Context, arg CreateVaultItemParams) error {
	_, err := q.db.ExecContext(ctx, createVaultItem, arg.VaultID, arg.VaultItemNameEncrypted)
	return err
}

const deleteCredentialByID = `-- name: DeleteCredentialByID :exec
DELETE FROM credentials WHERE credential_id = $1
`

func (q *Queries) DeleteCredentialByID(ctx context.Context, credentialID int32) error {
	_, err := q.db.ExecContext(ctx, deleteCredentialByID, credentialID)
	return err
}

const deleteUserByID = `-- name: DeleteUserByID :exec
DELETE FROM users WHERE userid = $1
`

func (q *Queries) DeleteUserByID(ctx context.Context, userid int32) error {
	_, err := q.db.ExecContext(ctx, deleteUserByID, userid)
	return err
}

const deleteVaultByID = `-- name: DeleteVaultByID :exec
DELETE FROM vaults WHERE vault_id = $1
`

func (q *Queries) DeleteVaultByID(ctx context.Context, vaultID int32) error {
	_, err := q.db.ExecContext(ctx, deleteVaultByID, vaultID)
	return err
}

const deleteVaultItemByID = `-- name: DeleteVaultItemByID :exec
DELETE FROM vault_items WHERE vault_item_id = $1
`

func (q *Queries) DeleteVaultItemByID(ctx context.Context, vaultItemID int32) error {
	_, err := q.db.ExecContext(ctx, deleteVaultItemByID, vaultItemID)
	return err
}

const getAllCredentials = `-- name: GetAllCredentials :many
SELECT c.encryptedCredName, c.encryptedCredPassword, c.credential_id FROM credentials c WHERE vault_item_id = $1
`

type GetAllCredentialsRow struct {
	Encryptedcredname     string
	Encryptedcredpassword string
	CredentialID          int32
}

func (q *Queries) GetAllCredentials(ctx context.Context, vaultItemID int32) ([]GetAllCredentialsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllCredentials, vaultItemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCredentialsRow
	for rows.Next() {
		var i GetAllCredentialsRow
		if err := rows.Scan(&i.Encryptedcredname, &i.Encryptedcredpassword, &i.CredentialID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT userid, username, master_password_hash, session_token FROM users WHERE username = $1
`

type GetUserByUsernameRow struct {
	Userid             int32
	Username           string
	MasterPasswordHash string
	SessionToken       sql.NullString
}

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (GetUserByUsernameRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByUsername, username)
	var i GetUserByUsernameRow
	err := row.Scan(
		&i.Userid,
		&i.Username,
		&i.MasterPasswordHash,
		&i.SessionToken,
	)
	return i, err
}

const insertSessionTokenWithUsername = `-- name: InsertSessionTokenWithUsername :exec
UPDATE users SET session_token = $1 WHERE username = $2
`

type InsertSessionTokenWithUsernameParams struct {
	SessionToken sql.NullString
	Username     string
}

func (q *Queries) InsertSessionTokenWithUsername(ctx context.Context, arg InsertSessionTokenWithUsernameParams) error {
	_, err := q.db.ExecContext(ctx, insertSessionTokenWithUsername, arg.SessionToken, arg.Username)
	return err
}
